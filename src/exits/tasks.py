import asyncio
import json
import logging
from typing import Sequence

import aiohttp
from aiohttp import ClientTimeout
from eth_typing import HexStr

from src.config import settings
from src.exits import relayer
from src.exits.keystores.local import LocalKeystore

logger = logging.getLogger(__name__)


async def run_tasks():
    # keystore consists of private/public key shares
    keystore = await LocalKeystore.load(settings.keystores_dir)

    # Deposit data file generated by Obol has public keys shuffled which is confusing.
    # Cluster lock contains public keys where ordering matches to keystores.
    # Rely on cluster lock.
    cluster_lock = load_cluster_lock()

    # these are full public keys, not shares
    public_keys = [
        HexStr(dv['distributed_public_key']) for dv in cluster_lock['distributed_validators']
    ]
    asyncio.create_task(poll_exits_and_push_signatures(public_keys, keystore))

    # Keep tasks running
    while True:
        await asyncio.sleep(0.1)


def load_cluster_lock() -> dict:
    return json.load(open(settings.cluster_lock_path, encoding='ascii'))


# pylint: disable=redefined-builtin
async def poll_exits_and_push_signatures(
    public_keys: Sequence[HexStr], keystore: LocalKeystore
) -> None:
    pushed_public_keys = set()
    pub_key_to_share = dict(zip(public_keys, keystore.public_keys))

    async with aiohttp.ClientSession(timeout=ClientTimeout(settings.relayer_timeout)) as session:
        while True:
            try:
                exits = await poll_exits(session)
                for exit in exits:
                    if exit['public_key'] in pushed_public_keys:
                        continue
                    pub_key_share = pub_key_to_share[exit['public_key']]
                    exit_signature = await keystore.get_exit_signature(
                        exit['validator_index'],
                        pub_key_share,
                        settings.network_config.SHAPELLA_FORK,
                        settings.network_config.GENESIS_VALIDATORS_ROOT,
                    )
                    await relayer.push_signature(session, exit['public_key'], exit_signature)
                    pushed_public_keys.add(exit['public_key'])
            except Exception:
                logger.exception('Failed to push exit signature')
            await asyncio.sleep(settings.poll_interval)


async def poll_exits(session):
    while True:
        if exits := await relayer.get_exits(session):
            return exits
        await asyncio.sleep(settings.poll_interval)
